diff --git a/lsvd_rbd.cc b/lsvd_rbd.cc
index 1e91a97..eeb76cb 100644
--- a/lsvd_rbd.cc
+++ b/lsvd_rbd.cc
@@ -132,6 +132,14 @@ public:
 					  size_t offset) = 0;
     virtual ssize_t read_numbered_object(int seq, char *buf, size_t len,
 					 size_t offset) = 0;
+    virtual int aio_read_object(const char *name, char *buf, size_t len, size_t offset,
+				void (*cb)(void*), void *ptr) = 0;
+    virtual int aio_read_num_obj(int seq, char *buf, size_t len, size_t offset,
+				 void (*cb)(void*), void *ptr) = 0;
+    virtual int aio_read_objectv(const char *name, iovec *iov, int iovcnt, size_t offset,
+				 void (*cb)(void*), void *ptr) = 0;
+    virtual int aio_read_num_objv(int seq, iovec *iov, int iovcnt, size_t offset,
+				  void (*cb)(void*), void *ptr) = 0;
     virtual std::string object_name(int seq) = 0;
     virtual ~backend(){}
 };
@@ -1018,7 +1026,7 @@ public:
 	    extents.push_back(it->vals(lba, lba+sectors));
 	}
 
-	if (n_hits + n_misses >= 1000) {
+	if (n_hits + n_misses >= 30000) {
 	    hit_rate = (hit_rate * 0.5) + (0.5 * n_hits) / (n_hits + n_misses);
 	    int x = n_lines_read;
 	    xprintf(DBG_HITS, "hit rate: %f lines_read %d\n", hit_rate, x);
@@ -1028,7 +1036,7 @@ public:
 	 * stop using the cache.
 	 */
 	std::uniform_real_distribution<double> unif(0.0,1.0);
-	bool use_cache = unif(rng) < 2 * hit_rate;
+	bool use_cache = unif(rng) < 2 * hit_rate + 0.001;
 	lk2.unlock();
 	lk.unlock();
 
@@ -1066,12 +1074,14 @@ public:
 		    if ((access_mask & bitmap[n]) == access_mask)
 			in_cache = true;
 		}
-		if (in_cache) {
-		    n_hits++;
+		if (in_cache) 
 		    (*in_use)[n]++;
+#if 0
+		    n_hits += (blk_top_offset - blk_offset);
 		}
 		else
 		    n_misses++;
+#endif
 		lk2.unlock();
 
 		if (in_cache) {
@@ -1080,6 +1090,8 @@ public:
 			finish = start + (blk_top_offset - blk_offset);
 		    size_t bytes = 512 * (finish - start);
 
+		    n_hits += (finish - start) / 8;
+		    
 		    xprintf(DBG_MAP, "rc: %d+%d in_cache: %d\n", (int)base, (int)bytes/512, (int)start);
 		    auto tmp = iovs.slice(buf_offset, buf_offset+bytes);
 		    assert(512L*start + tmp.bytes() <= dev_max);
@@ -1103,6 +1115,7 @@ public:
 		    base = limit;
 		    buf_offset += 512 * sectors;
 		    len -= 512 * sectors;
+		    // don't account for hits or misses here
 		}
 		else {
 		    n_lines_read++;
@@ -1115,6 +1128,10 @@ public:
 		    xprintf(DBG_MAP, "rc: %d+%d fetch -> cache (%d.%d)\n", (int)base,
 			    (int)(limit-base), (int)unit.obj, (int)blk_base);
 
+		    int h = (blk_top_offset - blk_offset)/8;
+		    n_misses += (unit_sectors - h);
+		    n_hits += h;
+
 		    iovs.slice(buf_offset,
 			       buf_offset+(finish-start)).copy_in(cache_line+start);
 
@@ -1296,6 +1313,22 @@ public:
 	    throw_fs_error("read_obj");
 	return val;
     }
+    int aio_read_object(const char *name, char *buf, size_t len, size_t offset,
+    			void (*cb)(void*), void *ptr) {
+	return 0;
+    }
+    int aio_read_num_obj(int seq, char *buf, size_t len, size_t offset,
+    			 void (*cb)(void*), void *ptr) {
+	return 0;
+    }
+    int aio_read_objectv(const char *name, iovec *iov, int iovcnt, size_t offset,
+    			 void (*cb)(void*), void *ptr) {
+	return 0;
+    }
+    int aio_read_num_objv(int seq, iovec *iov, int iovcnt, size_t offset,
+				  void (*cb)(void*), void *ptr) {
+	return 0;
+    }
     ~file_backend() {
 	free((void*)prefix);
 	for (auto it = cached_fds.begin(); it != cached_fds.end(); it++)
@@ -1904,6 +1937,58 @@ public:
 	free(buf);
 	return r;
     }
+    struct rna {
+    public:
+	void *ptr;
+	char *buf;
+	iovec *iov = NULL;
+	int    iovcnt = 0;
+	void (*cb)(void*);
+	rna(void *_ptr, char *_buf, void (*_cb)(void*)) : ptr(_ptr), buf(_buf), cb(_cb) {}
+    };
+    static void rna_cb(rados_completion_t c, void *ptr) {
+	rna *r = (rna*)ptr;
+	if (r->iov != NULL) {
+	    smartiov iovs(r->iov, r->iovcnt);
+	    iovs.copy_in(r->buf);
+	    free(r->buf);
+	}
+	r->cb(r->ptr);
+	rados_aio_release(c);
+	delete r;
+    }
+    int aio_read_object(const char *name, char *buf, size_t len, size_t offset,
+			void (*cb)(void*), void *ptr)
+    {
+	rados_completion_t c;
+	rna *r = new rna(ptr, NULL, cb);
+	rados_aio_create_completion((void*)r, rna_cb, NULL, &c);
+	return rados_aio_read(io_ctx, name, c, buf, len, offset);
+    }
+    int aio_read_num_obj(int seq, char *buf, size_t len, size_t offset,
+			 void (*cb)(void*), void *ptr) {
+	auto name = std::string(prefix) + "." + hex(seq);
+	return aio_read_object(name.c_str(), buf, len, offset, cb, ptr);
+    }
+    int aio_read_objectv(const char *name, iovec *iov, int iovcnt, size_t offset,
+			 void (*cb)(void*), void *ptr)
+    {
+	rados_completion_t c;
+	smartiov iovs(iov, iovcnt);
+	int len = iovs.bytes();
+	char *buf = (char*)malloc(len);
+	rna *r = new rna(ptr, buf, cb);
+	r->iov = iov;
+	r->iovcnt = iovcnt;
+	rados_aio_create_completion((void*)r, rna_cb, NULL, &c);
+	return rados_aio_read(io_ctx, name, c, buf, len, offset);
+    }
+    int aio_read_num_objv(int seq, iovec *iov, int iovcnt, size_t offset,
+			  void (*cb)(void*), void *ptr) {
+	auto name = std::string(prefix) + "." + hex(seq);
+	return aio_read_objectv(name.c_str(), iov, iovcnt, offset, cb, ptr);
+    }
+
     ~rados_backend() {
 	free((void*)prefix);
 	rados_ioctx_destroy(io_ctx);
